package nl.file.name;

import java.io.IOException;
import java.nio.file.DirectoryStream;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.nio.file.StandardCopyOption;

public class FileRename {
	/**
	 * Class renames files in a directory.
	 * 
	 * @param args
	 * 
	 */
	public static final int C_ARGS = 6;

	private static final String SEPARATOR =
	System.getProperty("file.separator");
	public static void main(String[] args) throws IOException {

		if (args.length != C_ARGS) {
			System.err
					.println("Program expects "
							+ C_ARGS
							+ " arguments:dirname, string to insert/delete in filenames before last occurrence of character, character,"
							+ " extension of files to process, character a (add) or d (delete) and p (print) or r (rename).");
			;
		}

		String dirname = args[0];
		String text = args[1];
		String character = args[2];
		String ext = args[3];
		String action = args[4];
		String rename = args[5];

		boolean move = rename.equalsIgnoreCase("r");

		process(dirname, text, character, ext, action, move);
	}

	private static void process(String dirname, String text, String character, String ext, String action, boolean move)
			throws IOException {

		Path dir = Paths.get(dirname);

		DirectoryStream<Path> stream = Files.newDirectoryStream(dir, "*." + ext);
		for (Path entry : stream) {
			String name = entry.getFileName().toString();
			if (name.lastIndexOf(character) != -1) {
				String newName = "";
				if (action.equalsIgnoreCase("a")) {
					newName = name.substring(0, name.lastIndexOf(character)) + text
							+ name.substring(name.lastIndexOf(character));
				} else {
					newName = name.substring(0, name.lastIndexOf(character)).substring(0, name.lastIndexOf(text))
							+ name.substring(name.lastIndexOf(character));
				}

				Path target = Paths.get(dirname + SEPARATOR + newName);
				if (move) {
					Files.move(entry, target, StandardCopyOption.ATOMIC_MOVE);
				} else {
					System.out.println(target);
				}
			}
		}
	}
}
